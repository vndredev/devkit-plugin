# Auto-generated by devkit-plugin. Do not edit manually.
# Variant: Python (uses pyproject.toml for version)
name: Release

on:
  push:
    branches: [main]

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'chore(release):')"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_PAT || github.token }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install toml
        run: pip install toml

      - name: Calculate Release
        id: release
        run: |
          python3 << 'EOF'
          import json
          import os
          import re
          import subprocess
          from datetime import date
          from pathlib import Path

          try:
              import toml
              HAS_TOML = True
          except ImportError:
              HAS_TOML = False

          def strip_jsonc_comments(text):
              """Remove // and /* */ comments from JSONC."""
              # Remove single-line comments (but not in strings)
              result = re.sub(r'(?<!:)//.*$', '', text, flags=re.MULTILINE)
              # Remove multi-line comments
              result = re.sub(r'/\*.*?\*/', '', result, flags=re.DOTALL)
              return result

          # Load config from .claude/.devkit/config.jsonc
          config = {}
          config_path = Path(".claude/.devkit/config.jsonc")
          if config_path.exists():
              try:
                  config = json.loads(strip_jsonc_comments(config_path.read_text()))
              except Exception:
                  pass

          # Get internal scopes from config (with fallback)
          INTERNAL_SCOPES = (
              config.get("git", {})
              .get("conventions", {})
              .get("scopes", {})
              .get("internal", ["internal", "review", "ci", "deps"])
          )

          # Get changelog audience from config (with fallback)
          AUDIENCE = config.get("changelog", {}).get("audience", "developer")

          # Section maps for different audiences
          SECTION_MAP_DEVELOPER = {
              "feat": "### Added",
              "fix": "### Fixed",
              "refactor": "### Changed",
              "perf": "### Changed",
              "chore": None,
              "docs": None,
              "ci": None,
              "test": None,
          }

          SECTION_MAP_USER = {
              "feat": "### What's New",
              "fix": "### Bug Fixes",
              "refactor": "### Improvements",
              "perf": "### Performance",
              "chore": None,
              "docs": None,
              "ci": None,
              "test": None,
          }

          # Select section map based on audience
          SECTION_MAP = SECTION_MAP_USER if AUDIENCE == "user" else SECTION_MAP_DEVELOPER

          def get_commit_type(msg):
              match = re.match(r"^(\w+)(?:\(.+\))?(!)?:", msg)
              return (match.group(1), bool(match.group(2))) if match else (None, False)

          def get_scope(msg):
              match = re.match(r"^\w+\(([^)]+)\)", msg)
              return match.group(1).lower() if match else None

          def format_entry(msg, audience="developer"):
              match = re.match(r"^(\w+)(?:\(([^)]+)\))?(!)?:\s*(.+)$", msg)
              if not match:
                  return msg.capitalize()
              scope = match.group(2)
              breaking = match.group(3)
              description = match.group(4).capitalize()

              # Add breaking indicator
              if breaking:
                  prefix = "BREAKING: " if audience == "developer" else "Important: "
                  description = prefix + description

              # Developer: show scope in bold
              # User: hide scope, just show description
              if audience == "developer" and scope:
                  return f"**{scope.capitalize()}**: {description}"
              return description

          def bump_version(version, commit_type, breaking):
              parts = version.lstrip("v").split(".")
              if len(parts) < 3:
                  parts = ["0", "0", "0"]
              major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2].split("-")[0])
              if breaking:
                  return f"{major + 1}.0.0"
              elif commit_type == "feat":
                  return f"{major}.{minor + 1}.0"
              else:
                  return f"{major}.{minor}.{patch + 1}"

          def get_version_pyproject():
              """Get version from pyproject.toml."""
              pyproject = Path("pyproject.toml")
              if not pyproject.exists() or not HAS_TOML:
                  return "0.0.0", None
              data = toml.loads(pyproject.read_text())
              version = data.get("project", {}).get("version", "0.0.0")
              return version, data

          def set_version_pyproject(data, new_version):
              """Update version in pyproject.toml."""
              if data and HAS_TOML:
                  if "project" not in data:
                      data["project"] = {}
                  data["project"]["version"] = new_version
                  Path("pyproject.toml").write_text(toml.dumps(data))

          def sync_other_versions(new_version):
              """Sync version to config.jsonc, package.json, plugin.json."""
              updated = []

              # Files to update: (path, is_jsonc, json_path_pattern)
              files = [
                  (".claude/.devkit/config.jsonc", True, r'("version"\s*:\s*")[^"]+(")', "project.version"),
                  ("package.json", False, ["version"]),
                  (".claude-plugin/plugin.json", False, ["version"]),
              ]

              for file_info in files:
                  path = Path(file_info[0])
                  if not path.exists():
                      continue

                  content = path.read_text()
                  is_jsonc = file_info[1]

                  if is_jsonc:
                      # JSONC: use regex to preserve comments
                      pattern = file_info[2]
                      match = re.search(pattern, content)
                      if match:
                          new_content = content[:match.start(1)] + match.group(1) + new_version + match.group(2) + content[match.end(2):]
                          path.write_text(new_content)
                          updated.append(str(path))
                  else:
                      # Regular JSON: parse and update
                      try:
                          data = json.loads(content)
                          json_path = file_info[2]
                          obj = data
                          for key in json_path[:-1]:
                              obj = obj.get(key, {})
                          if json_path[-1] in obj or len(json_path) == 1:
                              if len(json_path) == 1:
                                  data[json_path[0]] = new_version
                              else:
                                  obj[json_path[-1]] = new_version
                              path.write_text(json.dumps(data, indent=2) + "\n")
                              updated.append(str(path))
                      except json.JSONDecodeError:
                          pass

              return updated

          # Get last commit
          result = subprocess.run(["git", "log", "-1", "--pretty=%s"], capture_output=True, text=True)
          msg = result.stdout.strip()
          commit_type, breaking = get_commit_type(msg)

          # Check if release needed
          if not commit_type or commit_type in ["chore", "docs", "ci", "test"]:
              print(f"skip=true (non-release type: {commit_type})")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("skip=true\n")
              exit(0)

          scope = get_scope(msg)
          if scope and scope in INTERNAL_SCOPES:
              print(f"skip=true (internal scope: {scope})")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("skip=true\n")
              exit(0)

          # Get current version
          current, pyproject_data = get_version_pyproject()
          new_version = bump_version(current, commit_type, breaking)

          # Update pyproject.toml
          set_version_pyproject(pyproject_data, new_version)

          # Sync version to other files (config.jsonc, package.json, plugin.json)
          synced_files = sync_other_versions(new_version)
          if synced_files:
              print(f"Synced version to: {', '.join(synced_files)}")

          # Update changelog
          section = SECTION_MAP.get(commit_type)
          entry = f"- {format_entry(msg, AUDIENCE)}"
          today = date.today().isoformat()

          changelog = Path("CHANGELOG.md")
          lines = changelog.read_text().splitlines() if changelog.exists() else ["# Changelog"]
          header = f"## [v{new_version}] - {today}"

          version_idx = next((i for i, x in enumerate(lines) if x.startswith("## [v") and today in x), None)
          if version_idx is None:
              insert = ["", header]
              if section:
                  insert += ["", section, "", entry]
              for i, line in enumerate(insert):
                  lines.insert(1 + i, line)
          else:
              lines[version_idx] = header
              if section:
                  version_end = next((i for i in range(version_idx + 1, len(lines)) if lines[i].startswith("## ")), len(lines))
                  entry_text = entry.lstrip("- ").strip()
                  if not any(entry_text in lines[i] for i in range(version_idx, version_end)):
                      section_idx = next((i for i in range(version_idx + 1, version_end) if lines[i].strip() == section), None)
                      if section_idx:
                          insert_idx = section_idx + 1
                          while insert_idx < version_end and not lines[insert_idx].strip():
                              insert_idx += 1
                          lines.insert(insert_idx, entry)
                      else:
                          for i, content in enumerate(["", section, "", entry], start=1):
                              lines.insert(version_idx + i, content)

          changelog.write_text("\n".join(lines) + "\n")

          # Extract release notes
          notes_start = next((i for i, x in enumerate(lines) if f"v{new_version}" in x), 1)
          notes_end = next((i for i in range(notes_start + 1, len(lines)) if lines[i].startswith("## ")), len(lines))
          release_notes = "\n".join(lines[notes_start:notes_end]).strip()

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"version=v{new_version}\n")
              f.write("skip=false\n")

          Path("release_notes.md").write_text(release_notes)
          print(f"Version: v{new_version}")
          print(f"Entry: {entry}")
          print(f"Audience: {AUDIENCE}")
          EOF

      - name: Install uv
        if: steps.release.outputs.skip != 'true'
        uses: astral-sh/setup-uv@v5

      - name: Update uv.lock
        if: steps.release.outputs.skip != 'true'
        run: |
          if [ -f "uv.lock" ]; then
            uv lock
            echo "Updated uv.lock"
          fi

      - name: Commit Version Bump
        if: steps.release.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md pyproject.toml
          # Add version files if they exist
          [ -f ".claude/.devkit/config.jsonc" ] && git add .claude/.devkit/config.jsonc
          [ -f "package.json" ] && git add package.json
          [ -f ".claude-plugin/plugin.json" ] && git add .claude-plugin/plugin.json
          [ -f "uv.lock" ] && git add uv.lock
          git commit -m "chore(release): ${{ steps.release.outputs.version }} [skip ci]"
          git push

      - name: Create Tag
        if: steps.release.outputs.skip != 'true'
        run: |
          git tag ${{ steps.release.outputs.version }}
          git push origin ${{ steps.release.outputs.version }}

      - name: Create GitHub Release
        if: steps.release.outputs.skip != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release.outputs.version }}
          name: ${{ steps.release.outputs.version }}
          body_path: release_notes.md
          generate_release_notes: false
