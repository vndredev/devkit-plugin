# Auto-generated by devkit-plugin. Do not edit manually.
# Variant: Python (uses pyproject.toml for version)
name: Release

on:
  push:
    branches: [main]

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'chore(release):')"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_PAT || github.token }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install toml
        run: pip install toml

      - name: Calculate Release
        id: release
        run: |
          python3 << 'EOF'
          import os
          import re
          import subprocess
          from datetime import date
          from pathlib import Path

          try:
              import toml
              HAS_TOML = True
          except ImportError:
              HAS_TOML = False

          SECTION_MAP = {
              "feat": "### Added",
              "fix": "### Fixed",
              "refactor": "### Changed",
              "perf": "### Changed",
              "chore": None,
              "docs": None,
              "ci": None,
              "test": None,
          }
          INTERNAL_SCOPES = ["internal", "review", "ci", "deps"]

          def get_commit_type(msg):
              match = re.match(r"^(\w+)(?:\(.+\))?(!)?:", msg)
              return (match.group(1), bool(match.group(2))) if match else (None, False)

          def get_scope(msg):
              match = re.match(r"^\w+\(([^)]+)\)", msg)
              return match.group(1).lower() if match else None

          def format_entry(msg):
              match = re.match(r"^(\w+)(?:\(([^)]+)\))?(!)?:\s*(.+)$", msg)
              if not match:
                  return msg.capitalize()
              scope = match.group(2)
              description = match.group(4).capitalize()
              if scope:
                  return f"**{scope.capitalize()}**: {description}"
              return description

          def bump_version(version, commit_type, breaking):
              parts = version.lstrip("v").split(".")
              if len(parts) < 3:
                  parts = ["0", "0", "0"]
              major, minor, patch = int(parts[0]), int(parts[1]), int(parts[2].split("-")[0])
              if breaking:
                  return f"{major + 1}.0.0"
              elif commit_type == "feat":
                  return f"{major}.{minor + 1}.0"
              else:
                  return f"{major}.{minor}.{patch + 1}"

          def get_version_pyproject():
              """Get version from pyproject.toml."""
              pyproject = Path("pyproject.toml")
              if not pyproject.exists() or not HAS_TOML:
                  return "0.0.0", None
              data = toml.loads(pyproject.read_text())
              version = data.get("project", {}).get("version", "0.0.0")
              return version, data

          def set_version_pyproject(data, new_version):
              """Update version in pyproject.toml."""
              if data and HAS_TOML:
                  if "project" not in data:
                      data["project"] = {}
                  data["project"]["version"] = new_version
                  Path("pyproject.toml").write_text(toml.dumps(data))

          # Get last commit
          result = subprocess.run(["git", "log", "-1", "--pretty=%s"], capture_output=True, text=True)
          msg = result.stdout.strip()
          commit_type, breaking = get_commit_type(msg)

          # Check if release needed
          if not commit_type or commit_type in ["chore", "docs", "ci", "test"]:
              print(f"skip=true (non-release type: {commit_type})")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("skip=true\n")
              exit(0)

          scope = get_scope(msg)
          if scope and scope in INTERNAL_SCOPES:
              print(f"skip=true (internal scope: {scope})")
              with open(os.environ["GITHUB_OUTPUT"], "a") as f:
                  f.write("skip=true\n")
              exit(0)

          # Get current version
          current, pyproject_data = get_version_pyproject()
          new_version = bump_version(current, commit_type, breaking)

          # Update pyproject.toml
          set_version_pyproject(pyproject_data, new_version)

          # Update changelog
          section = SECTION_MAP.get(commit_type)
          entry = f"- {format_entry(msg)}"
          today = date.today().isoformat()

          changelog = Path("CHANGELOG.md")
          lines = changelog.read_text().splitlines() if changelog.exists() else ["# Changelog"]
          header = f"## [v{new_version}] - {today}"

          version_idx = next((i for i, x in enumerate(lines) if x.startswith("## [v") and today in x), None)
          if version_idx is None:
              insert = ["", header]
              if section:
                  insert += ["", section, "", entry]
              for i, line in enumerate(insert):
                  lines.insert(1 + i, line)
          else:
              lines[version_idx] = header
              if section:
                  version_end = next((i for i in range(version_idx + 1, len(lines)) if lines[i].startswith("## ")), len(lines))
                  entry_text = entry.lstrip("- ").strip()
                  if not any(entry_text in lines[i] for i in range(version_idx, version_end)):
                      section_idx = next((i for i in range(version_idx + 1, version_end) if lines[i].strip() == section), None)
                      if section_idx:
                          insert_idx = section_idx + 1
                          while insert_idx < version_end and not lines[insert_idx].strip():
                              insert_idx += 1
                          lines.insert(insert_idx, entry)
                      else:
                          for i, content in enumerate(["", section, "", entry], start=1):
                              lines.insert(version_idx + i, content)

          changelog.write_text("\n".join(lines) + "\n")

          # Extract release notes
          notes_start = next((i for i, x in enumerate(lines) if f"v{new_version}" in x), 1)
          notes_end = next((i for i in range(notes_start + 1, len(lines)) if lines[i].startswith("## ")), len(lines))
          release_notes = "\n".join(lines[notes_start:notes_end]).strip()

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              f.write(f"version=v{new_version}\n")
              f.write("skip=false\n")

          Path("release_notes.md").write_text(release_notes)
          print(f"Version: v{new_version}")
          print(f"Entry: {entry}")
          EOF

      - name: Commit Version Bump
        if: steps.release.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md pyproject.toml
          git commit -m "chore(release): ${{ steps.release.outputs.version }}"
          git push

      - name: Create Tag
        if: steps.release.outputs.skip != 'true'
        run: |
          git tag ${{ steps.release.outputs.version }}
          git push origin ${{ steps.release.outputs.version }}

      - name: Create GitHub Release
        if: steps.release.outputs.skip != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release.outputs.version }}
          name: ${{ steps.release.outputs.version }}
          body_path: release_notes.md
          generate_release_notes: false
