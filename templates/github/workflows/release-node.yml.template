# Auto-generated by devkit-plugin. Do not edit manually.
# Variant: Node.js (uses package.json for version)
name: Release

on:
  push:
    branches: [main]

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'chore(release):')"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_PAT || github.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Calculate Release
        id: release
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { execSync } = require('child_process');

          const SECTION_MAP = {
            feat: '### Added',
            fix: '### Fixed',
            refactor: '### Changed',
            perf: '### Changed',
          };
          const SKIP_TYPES = ['chore', 'docs', 'ci', 'test'];
          const INTERNAL_SCOPES = ['internal', 'review', 'ci', 'deps'];

          function getCommitType(msg) {
            const match = msg.match(/^(\w+)(?:\(.+\))?(!)?:/);
            return match ? [match[1], !!match[2]] : [null, false];
          }

          function getScope(msg) {
            const match = msg.match(/^\w+\(([^)]+)\)/);
            return match ? match[1].toLowerCase() : null;
          }

          function formatEntry(msg) {
            const match = msg.match(/^(\w+)(?:\(([^)]+)\))?(!)?:\s*(.+)$/);
            if (!match) return msg.charAt(0).toUpperCase() + msg.slice(1);
            const scope = match[2];
            const desc = match[4].charAt(0).toUpperCase() + match[4].slice(1);
            return scope ? `**${scope.charAt(0).toUpperCase() + scope.slice(1)}**: ${desc}` : desc;
          }

          function bumpVersion(version, type, breaking) {
            const [major, minor, patch] = version.replace(/^v/, '').split('.').map(n => parseInt(n) || 0);
            if (breaking) return `${major + 1}.0.0`;
            if (type === 'feat') return `${major}.${minor + 1}.0`;
            return `${major}.${minor}.${patch + 1}`;
          }

          function writeOutput(key, value) {
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `${key}=${value}\n`);
          }

          // Get last commit
          const msg = execSync('git log -1 --pretty=%s', { encoding: 'utf8' }).trim();
          const [commitType, breaking] = getCommitType(msg);

          // Check if release needed
          if (!commitType || SKIP_TYPES.includes(commitType)) {
            console.log(`skip=true (non-release type: ${commitType})`);
            writeOutput('skip', 'true');
            process.exit(0);
          }

          const scope = getScope(msg);
          if (scope && INTERNAL_SCOPES.includes(scope)) {
            console.log(`skip=true (internal scope: ${scope})`);
            writeOutput('skip', 'true');
            process.exit(0);
          }

          // Get current version from package.json
          let pkg = {};
          try {
            pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          } catch (e) {
            pkg = { version: '0.0.0' };
          }
          const current = pkg.version || '0.0.0';
          const newVersion = bumpVersion(current, commitType, breaking);

          // Update package.json
          pkg.version = newVersion;
          fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');

          // Update changelog
          const section = SECTION_MAP[commitType];
          const entry = `- ${formatEntry(msg)}`;
          const today = new Date().toISOString().split('T')[0];
          const header = `## [v${newVersion}] - ${today}`;

          let lines = ['# Changelog'];
          try {
            lines = fs.readFileSync('CHANGELOG.md', 'utf8').split('\n');
          } catch (e) {}

          const versionIdx = lines.findIndex(l => l.startsWith('## [v') && l.includes(today));
          if (versionIdx === -1) {
            const insert = ['', header];
            if (section) insert.push('', section, '', entry);
            lines.splice(1, 0, ...insert);
          } else {
            lines[versionIdx] = header;
            if (section) {
              const versionEnd = lines.findIndex((l, i) => i > versionIdx && l.startsWith('## '));
              const end = versionEnd === -1 ? lines.length : versionEnd;
              const entryText = entry.replace(/^- /, '').trim();
              const exists = lines.slice(versionIdx, end).some(l => l.includes(entryText));
              if (!exists) {
                const sectionIdx = lines.findIndex((l, i) => i > versionIdx && i < end && l.trim() === section);
                if (sectionIdx !== -1) {
                  let insertIdx = sectionIdx + 1;
                  while (insertIdx < end && !lines[insertIdx].trim()) insertIdx++;
                  lines.splice(insertIdx, 0, entry);
                } else {
                  lines.splice(versionIdx + 1, 0, '', section, '', entry);
                }
              }
            }
          }

          fs.writeFileSync('CHANGELOG.md', lines.join('\n') + '\n');

          // Extract release notes
          const notesStart = lines.findIndex(l => l.includes(`v${newVersion}`));
          let notesEnd = lines.findIndex((l, i) => i > notesStart && l.startsWith('## '));
          if (notesEnd === -1) notesEnd = lines.length;
          const releaseNotes = lines.slice(notesStart, notesEnd).join('\n').trim();

          writeOutput('version', `v${newVersion}`);
          writeOutput('skip', 'false');
          fs.writeFileSync('release_notes.md', releaseNotes);

          console.log(`Version: v${newVersion}`);
          console.log(`Entry: ${entry}`);
          EOF

      - name: Commit Version Bump
        if: steps.release.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md package.json
          [ -f package-lock.json ] && git add package-lock.json || true
          git commit -m "chore(release): ${{ steps.release.outputs.version }}"
          git push

      - name: Create Tag
        if: steps.release.outputs.skip != 'true'
        run: |
          git tag ${{ steps.release.outputs.version }}
          git push origin ${{ steps.release.outputs.version }}

      - name: Create GitHub Release
        if: steps.release.outputs.skip != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release.outputs.version }}
          name: ${{ steps.release.outputs.version }}
          body_path: release_notes.md
          generate_release_notes: false
