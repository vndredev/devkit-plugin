# Auto-generated by devkit-plugin. Do not edit manually.
# Variant: Node.js (uses package.json for version)
name: Release

on:
  push:
    branches: [main]

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, 'chore(release):')"

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_PAT || github.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Calculate Release
        id: release
        run: |
          node << 'EOF'
          const fs = require('fs');
          const { execSync } = require('child_process');

          // Strip JSONC comments (// and /* */)
          function stripJsoncComments(text) {
            return text
              .replace(/(?<!:)\/\/.*$/gm, '')  // Single-line comments
              .replace(/\/\*[\s\S]*?\*\//g, ''); // Multi-line comments
          }

          // Load config from .claude/.devkit/config.jsonc
          let config = {};
          try {
            const raw = fs.readFileSync('.claude/.devkit/config.jsonc', 'utf8');
            config = JSON.parse(stripJsoncComments(raw));
          } catch (e) {}

          // Get internal scopes from config (with fallback)
          const INTERNAL_SCOPES = config?.git?.conventions?.scopes?.internal || ['internal', 'review', 'ci', 'deps'];

          // Get changelog audience from config (with fallback)
          const AUDIENCE = config?.changelog?.audience || 'developer';

          // Section maps for different audiences
          const SECTION_MAP_DEVELOPER = {
            feat: '### Added',
            fix: '### Fixed',
            refactor: '### Changed',
            perf: '### Changed',
          };

          const SECTION_MAP_USER = {
            feat: "### What's New",
            fix: '### Bug Fixes',
            refactor: '### Improvements',
            perf: '### Performance',
          };

          // Select section map based on audience
          const SECTION_MAP = AUDIENCE === 'user' ? SECTION_MAP_USER : SECTION_MAP_DEVELOPER;

          const SKIP_TYPES = ['chore', 'docs', 'ci', 'test'];

          function getCommitType(msg) {
            const match = msg.match(/^(\w+)(?:\(.+\))?(!)?:/);
            return match ? [match[1], !!match[2]] : [null, false];
          }

          function getScope(msg) {
            const match = msg.match(/^\w+\(([^)]+)\)/);
            return match ? match[1].toLowerCase() : null;
          }

          function formatEntry(msg, audience = 'developer') {
            const match = msg.match(/^(\w+)(?:\(([^)]+)\))?(!)?:\s*(.+)$/);
            if (!match) return msg.charAt(0).toUpperCase() + msg.slice(1);
            const scope = match[2];
            const breaking = match[3];
            let desc = match[4].charAt(0).toUpperCase() + match[4].slice(1);

            // Add breaking indicator
            if (breaking) {
              const prefix = audience === 'developer' ? 'BREAKING: ' : 'Important: ';
              desc = prefix + desc;
            }

            // Developer: show scope in bold
            // User: hide scope, just show description
            if (audience === 'developer' && scope) {
              return `**${scope.charAt(0).toUpperCase() + scope.slice(1)}**: ${desc}`;
            }
            return desc;
          }

          function bumpVersion(version, type, breaking) {
            const [major, minor, patch] = version.replace(/^v/, '').split('.').map(n => parseInt(n) || 0);
            if (breaking) return `${major + 1}.0.0`;
            if (type === 'feat') return `${major}.${minor + 1}.0`;
            return `${major}.${minor}.${patch + 1}`;
          }

          function writeOutput(key, value) {
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `${key}=${value}\n`);
          }

          // Get last commit
          const msg = execSync('git log -1 --pretty=%s', { encoding: 'utf8' }).trim();
          const [commitType, breaking] = getCommitType(msg);

          // Check if release needed
          if (!commitType || SKIP_TYPES.includes(commitType)) {
            console.log(`skip=true (non-release type: ${commitType})`);
            writeOutput('skip', 'true');
            process.exit(0);
          }

          const scope = getScope(msg);
          if (scope && INTERNAL_SCOPES.includes(scope)) {
            console.log(`skip=true (internal scope: ${scope})`);
            writeOutput('skip', 'true');
            process.exit(0);
          }

          // Get current version from package.json
          let pkg = {};
          try {
            pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'));
          } catch (e) {
            pkg = { version: '0.0.0' };
          }
          const current = pkg.version || '0.0.0';
          const newVersion = bumpVersion(current, commitType, breaking);

          // Update package.json
          pkg.version = newVersion;
          fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\n');

          // Sync version to other files (config.jsonc, plugin.json)
          const versionFiles = [
            { path: '.claude/.devkit/config.jsonc', isJsonc: true },
            { path: '.claude-plugin/plugin.json', isJsonc: false },
          ];

          for (const { path, isJsonc } of versionFiles) {
            if (!fs.existsSync(path)) continue;

            if (isJsonc) {
              // JSONC: use regex to preserve comments
              let content = fs.readFileSync(path, 'utf8');
              content = content.replace(/("version":\s*")([^"]*)(")/, `$1${newVersion}$3`);
              fs.writeFileSync(path, content);
            } else {
              // Regular JSON: parse and update
              try {
                const data = JSON.parse(fs.readFileSync(path, 'utf8'));
                data.version = newVersion;
                fs.writeFileSync(path, JSON.stringify(data, null, 2) + '\n');
              } catch (e) {}
            }
          }

          // Update changelog
          const section = SECTION_MAP[commitType];
          const entry = `- ${formatEntry(msg, AUDIENCE)}`;
          const today = new Date().toISOString().split('T')[0];
          const header = `## [v${newVersion}] - ${today}`;

          let lines = ['# Changelog'];
          try {
            lines = fs.readFileSync('CHANGELOG.md', 'utf8').split('\n');
          } catch (e) {}

          const versionIdx = lines.findIndex(l => l.startsWith('## [v') && l.includes(today));
          if (versionIdx === -1) {
            const insert = ['', header];
            if (section) insert.push('', section, '', entry);
            lines.splice(1, 0, ...insert);
          } else {
            lines[versionIdx] = header;
            if (section) {
              const versionEnd = lines.findIndex((l, i) => i > versionIdx && l.startsWith('## '));
              const end = versionEnd === -1 ? lines.length : versionEnd;
              const entryText = entry.replace(/^- /, '').trim();
              const exists = lines.slice(versionIdx, end).some(l => l.includes(entryText));
              if (!exists) {
                const sectionIdx = lines.findIndex((l, i) => i > versionIdx && i < end && l.trim() === section);
                if (sectionIdx !== -1) {
                  let insertIdx = sectionIdx + 1;
                  while (insertIdx < end && !lines[insertIdx].trim()) insertIdx++;
                  lines.splice(insertIdx, 0, entry);
                } else {
                  lines.splice(versionIdx + 1, 0, '', section, '', entry);
                }
              }
            }
          }

          fs.writeFileSync('CHANGELOG.md', lines.join('\n') + '\n');

          // Extract release notes
          const notesStart = lines.findIndex(l => l.includes(`v${newVersion}`));
          let notesEnd = lines.findIndex((l, i) => i > notesStart && l.startsWith('## '));
          if (notesEnd === -1) notesEnd = lines.length;
          const releaseNotes = lines.slice(notesStart, notesEnd).join('\n').trim();

          writeOutput('version', `v${newVersion}`);
          writeOutput('skip', 'false');
          fs.writeFileSync('release_notes.md', releaseNotes);

          console.log(`Version: v${newVersion}`);
          console.log(`Entry: ${entry}`);
          console.log(`Audience: ${AUDIENCE}`);
          EOF

      - name: Commit Version Bump
        if: steps.release.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md package.json
          [ -f package-lock.json ] && git add package-lock.json || true
          [ -f .claude/.devkit/config.jsonc ] && git add .claude/.devkit/config.jsonc || true
          [ -f .claude-plugin/plugin.json ] && git add .claude-plugin/plugin.json || true
          git commit -m "chore(release): ${{ steps.release.outputs.version }} [skip ci]"
          git push

      - name: Create Tag
        if: steps.release.outputs.skip != 'true'
        run: |
          git tag ${{ steps.release.outputs.version }}
          git push origin ${{ steps.release.outputs.version }}

      - name: Create GitHub Release
        if: steps.release.outputs.skip != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release.outputs.version }}
          name: ${{ steps.release.outputs.version }}
          body_path: release_notes.md
          generate_release_notes: false
